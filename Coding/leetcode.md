## 记录一下每天写了点什么题
### 2023.5.9
Leetcode 349 两个数组的交集
* 直接暴力求解（用到python中set的交集，set是无序不重复元素的集合，使用“&”可以求集合的交）

Leetcode 205 同构字符串
* 使用两个dict构成双射

### 2023.5.11
Leetcode 102 二叉树的层序遍历

### 2023.5.13
Leetcode 624 数组列表中的最大距离
* 保存前i-1个数组中的最大值和最小值，与第i个数组的最小值和最大值作差，两个中最大的与之前的最大距离比较
* 最大值在i-1个数组的最大值和第i个数组的最大值中选择，最小值在i-1个数组的最小值和第i个数组的最小值中选择

Leetcode 280 摆动排序

Leetcode 1056 易混淆数

Leetcode 159 至多包含两个不同字符的最长子串
当前最长子串的RegEx为[ab]+b,下一字符为c
* 如果c==b，b的最晚出现位置+1
* 如果c!=b
>* 最长子串中只有一种字符b时可以看成c==a
>* c!=a，则滑动窗口左端变为a的最晚出现位置+1
>* a的最晚出现位置更新为当前位置
>* 交换a和b的最晚出现位置（原来的b的最晚出现位置变成a的最晚出现位置，现在新的c的位置变成b的最晚出现位置）

#Leetcode 340 至多包含K个不同字符的最长子串 还没做

### 2023.5.14
Leetcode 487 最大连续1的个数（滑动窗口）
* 在新加入的数为1的情况下，无需任何改变
* 在新加入的数为0的情况下
>* 如果之前没有0，则将滑动窗口中0的个数更改为1
>* 如果之前有0，则将滑动窗口的左端变为最近一次0的右端
>* 更新最近一次0的右端为当前位置+1
* 计算长度

Leetcode 760 找出变位映射（哈希）
* enumerate(x): 返回 index：$x_i$

Leetcode 266 回文排列（哈希）
* dict.get(key,0)+1（如果key已存在在dict中则用get找到对应的value并+1，不存在则为默认值0+1）
* 用dict.items()找到k,v对，如果大于一个为奇数则不能构成回文

### 2023.5.15
Leetcode 298 二叉树最长连续序列（二叉树）
* 当前结点node：如果没有左结点和右结点，则返回1
* 如果左结点==当前结点+1，l深度为左子树深度+1，并与最大深度比较；如果左结点!=当前结点+1，则只需要进行深搜（不更新l以及比较大小）
* 如果右结点==当前结点+1，r深度为右子树深度+1，并与最大深度比较；如果右结点!=当前结点+1，则只需要进行深搜（不更新r以及比较大小）
* 当前结点深度=max(l,r)

### 2023.5.16
Leetcode 549 二叉树中最长的连续序列（二叉树）
* 每个结点返回两个值：当前结点的递减值和递增值（没有子结点为1，空结点返回0）
* 左结点如果为递增（递减），则递增=max(左递增+1,递增)（递减=max(左递减+1,递减)），否则还保持原状
* 右结点如果为递增（递减），则递增=max(右递增+1,递增)（递减=max(左递减+1,递减)），否则还保持原状
* self.max_len=max(self.max_len,递增+递减-1)
* 返回递增和递减

Leetcode 490 迷宫（bfs）
* 将起始点加入队列
* 将队列中的点取出，对于所有可以走的方向走到头（用while向前直到碰到墙）
* 将这些点加入队列（需要之前没加入过的，可以用二维数组记录），重复二三步直到到达终点或队列为空

Leetcode 505 迷宫 II（bfs）
* 与上一题类似，但是将之前用于记录是否加入过队列的二维bool数组变为记录每个点最短路径长度的二维数组
* 判断是否加入过变成*当前走过距离*是否短于*该点之前的最短路径*

Leetcode 1086 前五科的均分（堆）
* 再复习一下堆吧...

### 2023.5.17
Leetcode 270 最接近的二叉搜索树值（二叉搜索树）

Leetcode 255 验证前序遍历序列二叉搜索树 （二叉搜索树）
* 当前结点小于栈顶
>* 如果当前结点大于temp_root，压栈
>* 否则返回false（此时的点在temp_root为根的右子树，但是小于temp_root）
* 当前结点大于栈顶
>* 多次弹栈，直到栈顶大于当前结点或为空，最后一次弹出的结点为temp_root，之后加入的必须大于它
>* 将当前结点加入栈

Leetcode 277 搜寻名人（图）
* 一个for循环遍历所有人（用knows（a,b）如果为true说明a一定不是名人，b可能是名人，为false说明b一定不是名人a可能是名人）
* 再去判断最后这个人是不是名人，不是返回-1，是返回他的编号

### 2023.5.18
Leetcode 582 杀掉进程（哈希+dfs）

Leetcode 1197 进击的骑士（bfs+剪枝）
* 在四个象限和在第一个象限是一样的距离（如(5,1), (-5,1), (5,-1), (-5,-1)）所以(x,y)可以都放在第一象限(abs(x),abs(y))
* 点只能在一定范围内(0<=now_x<x,0<=now_y<y)，但为了斡旋可以稍微放宽（-5<now_x<x+5,-5<now_y<y+5）
* 记忆化：加入过队列的点不能再次加入（用set(tuple)）

Leetcode 286 墙与门（bfs+剪枝）
* 找到所有的门
* 从门开始更新距离(pop)：
>* 如果是0或-1，不用更新
>* 否则如果当前距离小于room中的距离，更新room中的，将当前room加入队列

Leetcode 317 离建筑物最近的距离（bfs+剪枝）

Leetcode 250 统计同值子树（递归）

### 2023.5.20 
Leetcode 1120 子树的最大平均值（二叉树）

### 2023.5.21
Leetcode 734 句子相似性（hash）

Leetcode 1165 单行键盘（hash）







