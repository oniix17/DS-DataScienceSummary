## 记录一下每天写了点什么题
### 2023.5.9
Leetcode 349 两个数组的交集
* 直接暴力求解（用到python中set的交集，set是无序不重复元素的集合，使用“&”可以求集合的交）

Leetcode 205 同构字符串
* 使用两个dict构成双射

### 2023.5.11
Leetcode 102 二叉树的层序遍历

### 2023.5.13
Leetcode 624 数组列表中的最大距离
* 保存前i-1个数组中的最大值和最小值，与第i个数组的最小值和最大值作差，两个中最大的与之前的最大距离比较
* 最大值在i-1个数组的最大值和第i个数组的最大值中选择，最小值在i-1个数组的最小值和第i个数组的最小值中选择

Leetcode 280 摆动排序

Leetcode 1056 易混淆数

Leetcode 159 至多包含两个不同字符的最长子串
当前最长子串的RegEx为[ab]+b,下一字符为c
* 如果c==b，b的最晚出现位置+1
* 如果c!=b
>* 最长子串中只有一种字符b时可以看成c==a
>* c!=a，则滑动窗口左端变为a的最晚出现位置+1
>* a的最晚出现位置更新为当前位置
>* 交换a和b的最晚出现位置（原来的b的最晚出现位置变成a的最晚出现位置，现在新的c的位置变成b的最晚出现位置）

#Leetcode 340 至多包含K个不同字符的最长子串 还没做

### 2023.5.14
Leetcode 487 最大连续1的个数（滑动窗口）
* 在新加入的数为1的情况下，无需任何改变
* 在新加入的数为0的情况下
>* 如果之前没有0，则将滑动窗口中0的个数更改为1
>* 如果之前有0，则将滑动窗口的左端变为最近一次0的右端
>* 更新最近一次0的右端为当前位置+1
* 计算长度

Leetcode 760 找出变位映射（哈希）
* enumerate(x): 返回 index：$x_i$

Leetcode 266 回文排列（哈希）
* dict.get(key,0)+1（如果key已存在在dict中则用get找到对应的value并+1，不存在则为默认值0+1）
* 用dict.items()找到k,v对，如果大于一个为奇数则不能构成回文

# 2023.5.15
Leetcode 298 二叉树最长连续序列（二叉树）
* 当前结点node：如果没有左结点和右结点，则返回1
* 如果左结点==当前结点+1，l深度为左子树深度+1，并与最大深度比较；如果左结点!=当前结点+1，则只需要进行深搜（不更新l以及比较大小）
* 如果右结点==当前结点+1，r深度为右子树深度+1，并与最大深度比较；如果右结点!=当前结点+1，则只需要进行深搜（不更新r以及比较大小）
* 当前结点深度=max(l,r)

# 2023.5.16
Leetcode 549 二叉树中最长的连续序列（二叉树）
* 每个结点返回两个值：当前结点的递减值和递增值（没有子结点为1，空结点返回0）
* 左结点如果为递增（递减），则递增=max(左递增+1,递增)（递减=max(左递减+1,递减)），否则还保持原状
* 右结点如果为递增（递减），则递增=max(右递增+1,递增)（递减=max(左递减+1,递减)），否则还保持原状
* self.max_len=max(self.max_len,递增+递减-1)
* 返回递增和递减

Leetcode 490 迷宫（bfs）
* 将起始点加入队列
* 将队列中的点取出，对于所有可以走的方向走到头（用while向前直到碰到墙）
* 将这些点加入队列（需要之前没加入过的，可以用二维数组记录），重复二三步直到到达终点或队列为空

Leetcode 505 迷宫 II（bfs）
* 与上一题类似，但是将之前用于记录是否加入过队列的二维bool数组变为记录每个点最短路径长度的二维数组
* 判断是否加入过变成*当前走过距离*是否短于*该点之前的最短路径*

Leetcode 1086 前五科的均分（堆）
* 再复习一下堆吧...
* 





